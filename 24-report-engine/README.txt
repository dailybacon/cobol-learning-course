       ============================================
        LESSON 24: Portfolio Project
        Parameter-Driven Report Engine
       ============================================

        OVERVIEW
       ============================================
        Every mainframe shop has hundreds of reports.
        Month-end reports, daily balances, regulatory
        filings, audit extracts, exception lists.
        Most of them are separate COBOL programs
        that do 90% the same thing: read a file,
        format columns, group and subtotal, print.

        What if one program could generate any of
        them, driven by a control file?

        This project builds a general-purpose report
        engine. Feed it a data file and a report
        definition, and it produces formatted output.
        This is not just a clever exercise — it is
        the kind of tool that saves a shop hundreds
        of hours when someone says "I need 15 new
        reports by Friday."

        More importantly, it demonstrates that you
        think in systems and abstractions, not just
        line-by-line code. That is what separates
        a developer from a senior developer.


        WHAT YOU ARE BUILDING
       ============================================

        PROGRAM 1: RPTENG (Report Engine)
          The main engine. Reads two inputs:
            a. A report definition file (control file)
            b. A data file
          Produces formatted report output.

          The engine does NOT know what the data
          means. It does not know it is looking at
          employee records or bank transactions.
          It only knows: "field 3 is 20 characters
          wide, starts at position 15, goes in
          column 2 of the report, and has the
          header EMPLOYEE NAME."

          The definition file tells it everything:
            - What fields exist in the data
            - Which fields to display
            - Column headers
            - Sort/group fields
            - Where to subtotal
            - Page layout (width, length, margins)
            - Title and footer text

        PROGRAM 2: RPTDEF (Definition Builder)
          Interactive program that helps the user
          create report definition files. Instead
          of hand-editing the control file, the user
          answers questions:
            - What is the data file name?
            - How wide is each record?
            - Define field 1: name, start pos, length,
              type (alpha/numeric/date)?
            - Which fields to include in the report?
            - Sort by which field?
            - Group/subtotal by which field?
            - Report title?
            - Page width (80, 132, custom)?

          Writes a report definition file that
          RPTENG can consume.

        PROGRAM 3: RPTVAL (Definition Validator)
          Reads a report definition file and checks
          it for errors before RPTENG tries to use
          it:
            - Do field positions overlap?
            - Do field positions exceed record length?
            - Are referenced field names valid?
            - Do numeric operations reference numeric
              fields only?
            - Does the report width accommodate all
              selected columns?
            - Are subtotal fields valid?
          Produces a validation report: either a
          clean bill of health or a list of errors
          with line numbers and descriptions.

        PROGRAM 4: RPTSORT (Pre-Sort Utility)
          Sorts the input data file by the fields
          specified in the report definition. Not
          all reports need sorting, but grouped
          reports require data sorted by the group
          field. Uses SORT with dynamic key positions
          read from the definition file.

        PROGRAM 5: RPTQUE (Report Queue Manager)
          Manages a queue of report requests.
          Reads a job file listing multiple reports
          to generate (definition file + data file
          pairs). Processes them in priority order.
          Tracks status: pending, processing,
          complete, failed. Writes a job summary
          when all reports are done.


        REPORT DEFINITION FILE FORMAT
       ============================================
        Design this carefully. It is the heart of
        the system. Each line in the definition file
        is a control card with a type code and
        parameters. Suggested structure:

        HEADER CARDS (one each, required):
          HD TITLE1 Monthly Sales Report
          HD TITLE2 For Period Ending 01/2026
          HD FOOTER Page generated by RPTENG
          HD PGWID  132
      *>    Page width in characters
          HD PGLEN  60
      *>    Lines per page before page break
          HD DATFIL sales.dat
      *>    Input data file name
          HD RECLEN 80
      *>    Record length of data file

        FIELD DEFINITION CARDS (one per field):
          FD 01 REGION     POS 001 LEN 010 TYP A
          FD 02 SALESREP   POS 011 LEN 020 TYP A
          FD 03 PRODUCT    POS 031 LEN 015 TYP A
          FD 04 QUANTITY   POS 046 LEN 005 TYP N DEC 0
          FD 05 UNIT-PRICE POS 051 LEN 008 TYP N DEC 2
          FD 06 TOTAL-SALE POS 059 LEN 010 TYP N DEC 2
          FD 07 SALE-DATE  POS 069 LEN 008 TYP D FMT YYYYMMDD

      *>  Field card format:
      *>    FD = field definition
      *>    ## = field number (for reference)
      *>    name = field name (for headers)
      *>    POS = starting position in data record
      *>    LEN = field length in data record
      *>    TYP = A(lpha), N(umeric), D(ate)
      *>    DEC = decimal places (numeric only)
      *>    FMT = date format (date only)

        COLUMN CARDS (which fields appear, in order):
          CL 01 FLD 02 HDR "Sales Rep" WID 22 ALN L
          CL 02 FLD 01 HDR "Region"    WID 12 ALN L
          CL 03 FLD 04 HDR "Qty"       WID 07 ALN R
          CL 04 FLD 06 HDR "Sale Amt"  WID 12 ALN R FMT $$$,$$9.99
          CL 05 FLD 07 HDR "Date"      WID 10 ALN C FMT MM/DD/YYYY

      *>  Column card format:
      *>    CL = column definition
      *>    ## = column sequence number
      *>    FLD = which field number to display
      *>    HDR = column header text
      *>    WID = column width in report
      *>    ALN = alignment: L(eft), R(ight), C(enter)
      *>    FMT = display format (optional)

        GROUP/SORT CARDS:
          GR FLD 01 BRK Y
      *>    Group by field 01 (REGION)
      *>    BRK Y = page break between groups
      *>    BRK N = blank line between groups

        SUBTOTAL CARDS:
          ST FLD 04 LBL "Qty Total:"   OPR SUM
          ST FLD 06 LBL "Sales Total:" OPR SUM
          ST FLD 06 LBL "Average Sale:" OPR AVG
          ST FLD 04 LBL "Max Qty:"      OPR MAX
          ST FLD 04 LBL "Min Qty:"      OPR MIN

      *>  Subtotal card format:
      *>    ST = subtotal definition
      *>    FLD = which field to aggregate
      *>    LBL = label to print
      *>    OPR = SUM, AVG, CNT, MAX, MIN

        GRAND TOTAL CARDS:
          GT FLD 04 LBL "Grand Total Qty:"   OPR SUM
          GT FLD 06 LBL "Grand Total Sales:" OPR SUM
          GT FLD 06 LBL "Overall Average:"   OPR AVG

        FILTER CARDS (optional):
          FL FLD 06 OPR GT VAL 1000.00
      *>    Only include records where field 06 > 1000
          FL FLD 01 OPR EQ VAL "East"
      *>    Only include records where field 01 = "East"

      *>  Filter operators:
      *>    EQ = equals
      *>    NE = not equals
      *>    GT = greater than
      *>    LT = less than
      *>    GE = greater or equal
      *>    LE = less or equal


        REPORT ENGINE PROCESSING LOGIC
       ============================================
        RPTENG should process in this order:

        1. INITIALIZATION
           Read the definition file.
           Parse and store all cards in tables:
             - Header info in working variables
             - Up to 20 field definitions in a table
             - Up to 10 column definitions in a table
             - Up to 5 group definitions in a table
             - Up to 10 subtotal definitions
             - Up to 10 grand total definitions
             - Up to 5 filter definitions
           Open the data file and report output file.

        2. PAGE HEADER
           Write title lines (centered at page width).
           Write column headers (positioned and
           formatted per column definitions).
           Write a separator line (dashes under
           each column header).
           Set line counter to header line count.

        3. RECORD PROCESSING LOOP
           For each data record:
             a. Apply filters. If any filter
                excludes the record, skip it.
             b. Check group field. If the value
                changed from the previous record:
                - Print subtotals for the previous
                  group (if any)
                - Reset subtotal accumulators
                - If BRK Y, start new page
                - Print group header
             c. Check page overflow. If line counter
                >= page length, start a new page
                with headers.
             d. Extract each column's field from
                the data record using POS and LEN.
             e. Format each field per its column
                definition (alignment, numeric
                editing, date formatting).
             f. Assemble the detail line.
             g. Write the detail line.
             h. Accumulate subtotals and grand totals.
             i. Increment line counter.

        4. FINAL SUBTOTALS
           After last record, print subtotals for
           the last group.

        5. GRAND TOTALS
           Print a separator line.
           Print each grand total line.

        6. REPORT FOOTER
           Print footer text.
           Print record count and page count.

        7. CLEANUP
           Close all files.
           Display summary to screen.


        SAMPLE REPORTS TO GENERATE
       ============================================
        Create definition files for at least these
        four reports to prove the engine works:

        REPORT A: Sales by Region
          Data: sales records
          Groups: by region
          Columns: rep, product, qty, amount, date
          Subtotals: qty sum, amount sum per region
          Grand total: overall qty, amount, avg
          Page width: 80

        REPORT B: Employee Directory
          Data: employee records (from earlier lessons)
          Groups: by department
          Columns: ID, name, title, salary, hire date
          Subtotals: count and avg salary per dept
          Grand total: total employees, avg salary
          Filter: only active employees
          Page width: 80

        REPORT C: Transaction Ledger
          Data: banking transactions (lesson 20 data)
          Groups: by account number
          Columns: date, type, description, amount,
                   balance
          Subtotals: deposit total, withdrawal total
          Grand total: net activity
          Page width: 132 (wide format)

        REPORT D: Filtered Exception Report
          Data: same banking transactions
          Filter: amount > 10000
          Groups: by transaction type
          Columns: account, date, amount, description
          Subtotals: count and sum per type
          Grand total: total exceptions
          Page width: 80

        The point: ONE program, FOUR completely
        different reports, ZERO code changes. Only
        the definition file changes.


        REPORT QUEUE JOB FILE FORMAT
       ============================================
        For RPTQUE, create a simple job file:

          JOB 001 PRI 1 DEF sales-region.def
          JOB 002 PRI 2 DEF employee-dir.def
          JOB 003 PRI 1 DEF txn-ledger.def
          JOB 004 PRI 3 DEF exception-rpt.def

      *>  JOB = job card
      *>  ### = job number
      *>  PRI = priority (1=high, 2=normal, 3=low)
      *>  DEF = report definition file to process

        RPTQUE reads this file, sorts by priority,
        and processes each report in order. After
        each report, update status:

          JOB 001: COMPLETE  (23 pages, 0 errors)
          JOB 003: COMPLETE  (45 pages, 0 errors)
          JOB 002: COMPLETE  (8 pages, 0 errors)
          JOB 004: FAILED    (definition error line 12)

        This simulates JES2 job scheduling on a
        mainframe. Simple version, same concept.


        HOW TO BUILD THIS (Suggested Order)
       ============================================

        Phase 1: Definition Format (Week 1)
          1. Design the definition file format.
             Write the four sample definition files
             by hand. Make sure the format is
             consistent and parseable.
          2. Write RPTVAL. This forces you to fully
             specify and understand every card type
             before you try to process them.
          3. Test RPTVAL against your definition
             files. Also write an intentionally bad
             definition file and verify it catches
             every error.

        Phase 2: Core Engine (Week 2)
          4. Write RPTENG. Start with the simplest
             case: no grouping, no subtotals, no
             filters. Just read data, format columns,
             print detail lines with page breaks.
          5. Add filtering. Test with Report D.
          6. Add grouping and subtotals.
             Test with Report A.
          7. Add grand totals.
          8. Test all four reports.

        Phase 3: Utilities (Week 3)
          9. Write RPTSORT. Read the group field
             from the definition file and sort the
             data file accordingly.
         10. Write RPTDEF. The interactive builder.
             This is a SCREEN SECTION opportunity
             if you want to practice lesson 17.
         11. Use RPTDEF to create a fifth report
             definition from scratch.

        Phase 4: Queue Manager (Week 4)
         12. Write RPTQUE. Job file parsing,
             priority sorting, sequential execution,
             status tracking.
         13. Test with all four reports queued.
         14. Test with a bad definition in the queue
             (should fail that job and continue).
         15. Write the README.


        DESIGN CHALLENGES
       ============================================
        These are the hard parts. Think through
        them before coding:

        DYNAMIC FIELD EXTRACTION:
          You cannot hardcode field positions. The
          engine reads POS and LEN from the definition
          and must use reference modification to
          extract fields at runtime:
            DATA-RECORD(WS-POS:WS-LEN)
          This means your data record is a single
          PIC X(n) field, not a structured 01 level.
          That is intentional and correct.

        DYNAMIC NUMERIC FORMATTING:
          For numeric fields, you must convert a
          substring of the data record to a numeric
          variable, then format it per the column
          definition. This requires careful MOVE
          and COMPUTE logic. Handle decimal places
          correctly — a field stored as "0019999"
          with DEC 2 means $199.99.

        DYNAMIC ALIGNMENT:
          Left-align means pad right with spaces.
          Right-align means pad left with spaces.
          Center means split the padding.
          You need a formatting paragraph that takes
          a field value, a width, and an alignment
          code and produces a formatted string.

        ACCUMULATOR MANAGEMENT:
          Subtotals and grand totals must work for
          ANY numeric field, not just hardcoded ones.
          Store accumulators in a table indexed by
          subtotal definition number. Reset subtotal
          accumulators on group breaks. Never reset
          grand total accumulators.

        PAGE OVERFLOW:
          When a group break coincides with page
          overflow, handle it correctly: print
          subtotals on the current page, then break
          to a new page for the next group. Do not
          print subtotals at the top of a new page
          with no preceding detail lines.


        SKILLS DEMONSTRATED
       ============================================
          - Parameter-driven / metadata-driven design
          - Control file parsing
          - Dynamic field extraction (ref modification)
          - Runtime formatting and alignment
          - Accumulator pattern with dynamic fields
          - Page break and overflow management
          - Job queue simulation (JES2 concepts)
          - Interactive program design (RPTDEF)
          - Input validation (RPTVAL)
          - Separation of data from presentation
          - Systems thinking and abstraction

        This project shows you can build tools,
        not just use them. That is a senior-level
        skill. Pair it with the banking or insurance
        project and you demonstrate both domain
        expertise and engineering capability.


        COMPILATION
       ============================================
        cobc -x rpteng.cob -o rpteng
        cobc -x rptdef.cob -o rptdef
        cobc -x rptval.cob -o rptval
        cobc -x rptsort.cob -o rptsort
        cobc -x rptque.cob -o rptque
